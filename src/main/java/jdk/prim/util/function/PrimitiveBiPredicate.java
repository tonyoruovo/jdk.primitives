package jdk.prim.util.function;

import java.util.function.BiPredicate;

/**
 * An interface that provides primitive support for the {@code BiPredicate} interface.
 * Support exists for a primitive for every parameter and every case - from those where
 * only one of the parameters is a primitive ({@code OFXxx} and {@code AndXxx}) to those
 * where all parameters are primitives.
 * 
 * <p>
 * It also defines primitive alternatives for {@link #or(BiPredicate)}, {@link #negate()}
 * and {@link #and(BiPredicate)}.
 * <p>
 * It uses the following interface naming convention: {@code Of*} refers to the first argument,
 * {@code And*} refers to the second argument. When they are nested, then the
 * convention remains mostly the same.
 * <p>
 * Note that no exception handling is done on any of the methods ({@code default} or otherwise)
 * in these interfaces. If an exception is thrown in any method, the behaviour of that method will
 * be similar to it's JDK equivalent.
 * 
 * @see BiPredicate
 */
@FunctionalInterface
public interface PrimitiveBiPredicate<OF, AND> extends BiPredicate<OF, AND> {

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyDouble(double, Object) applyDouble} to
     * be of type {@code double} and the second parameter to be of type
     * {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfDouble<AND> extends PrimitiveBiPredicate<java.lang.Double, AND> {
        /**
         * Evaluates this predicate by receiving a {@code double} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code double} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testDouble(double x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls
         *           {@link #testDouble(double, Object)}
         */
        @Override
        default boolean test(java.lang.Double x, AND y) {
            return testDouble(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testDouble(double, Object)} is the method
         *           that is negated
         *           and {@code OfDouble} is returned.
         */
        @Override
        default OfDouble<AND> negate() {
            return (x, y) -> !testDouble(x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code double}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code long}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code int}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code float}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code char}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code short}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code byte}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code boolean}
         * @see BiPredicate#or
         */
        default OfDouble<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code double}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code int}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code float}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code char}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code short}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code byte}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testDouble(double, Object)}
         *         is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code double}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default OfDouble<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfDouble} that expects a {@code double} in the second argument
         * in the abstract method {@link #testDouble(double, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfDouble<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Double)}
             */
            boolean testDouble(double x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Double y) {
                return testDouble(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndDouble negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code long} in the second argument
         * in the abstract method {@link #testDouble(double, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfDouble<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Long)}
             */
            boolean testDouble(double x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Long y) {
                return testDouble(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndLong negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code int} in the second argument
         * in the abstract method {@link #testDouble(double, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfDouble<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Int)}
             */
            boolean testDouble(double x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Integer y) {
                return testDouble(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndInt negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code float} in the second argument
         * in the abstract method {@link #testDouble(double, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfDouble<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Float)}
             */
            boolean testDouble(double x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Float y) {
                return testDouble(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndFloat negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code char} in the second argument
         * in the abstract method {@link #testDouble(double, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfDouble<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Char)}
             */
            boolean testDouble(double x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Character y) {
                return testDouble(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndChar negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code short} in the second argument
         * in the abstract method {@link #testDouble(double, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfDouble<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Short)}
             */
            boolean testDouble(double x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Short y) {
                return testDouble(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndShort negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testDouble(double, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfDouble<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Byte)}
             */
            boolean testDouble(double x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Byte y) {
                return testDouble(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndByte negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfDouble} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testDouble(double, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfDouble<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testDouble(double, java.lang.Boolean)}
             */
            boolean testDouble(double x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testDouble(double x, java.lang.Boolean y) {
                return testDouble(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfDouble.AndBoolean negate() {
                return (x, y) -> !testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <OR>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfDouble.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testDouble(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and it's first argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and it's first
             *              argument
             *              and an object of type {@code <AND>} as it's second argument
             * @return a newly composed predicate whose {@link #testDouble(double, Object)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfDouble.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testDouble(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyLong(long, Object) applyLong} to
     * be of type {@code long} and the second parameter to be of type {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfLong<AND> extends PrimitiveBiPredicate<java.lang.Long, AND> {
        /**
         * Evaluates this predicate by receiving a {@code long} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code long} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testLong(long x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls {@link #testLong(long, Object)}
         */
        @Override
        default boolean test(java.lang.Long x, AND y) {
            return testLong(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testLong(long, Object)} is the method
         *           that is negated
         *           and {@code OfLong} is returned.
         */
        @Override
        default OfLong<AND> negate() {
            return (x, y) -> !testLong(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code double}
         * @see BiPredicate#or
         */
        default OfLong<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testLong(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#or
         */
        default OfLong<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testLong(x, y) || other.testLong(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code int}
         * @see BiPredicate#or
         */
        default OfLong<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code float}
         * @see BiPredicate#or
         */
        default OfLong<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testLong(x, y) || other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code char}
         * @see BiPredicate#or
         */
        default OfLong<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code short}
         * @see BiPredicate#or
         */
        default OfLong<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code byte}
         * @see BiPredicate#or
         */
        default OfLong<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#or
         */
        default OfLong<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code double}
         * @see BiPredicate#and
         */
        default OfLong<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testLong(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default OfLong<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testLong(x, y) && other.testLong(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code int}
         * @see BiPredicate#and
         */
        default OfLong<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code float}
         * @see BiPredicate#and
         */
        default OfLong<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testLong(x, y) && other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code char}
         * @see BiPredicate#and
         */
        default OfLong<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code short}
         * @see BiPredicate#and
         */
        default OfLong<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code byte}
         * @see BiPredicate#and
         */
        default OfLong<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testLong(long, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default OfLong<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfLong} that expects a {@code double} in the second argument
         * in the abstract method {@link #testLong(long, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfLong<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Double)}
             */
            boolean testLong(long x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Double y) {
                return testLong(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndDouble negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testLong(long, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code long} in the second argument
         * in the abstract method {@link #testLong(long, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfLong<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Long)}
             */
            boolean testLong(long x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Long y) {
                return testLong(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndLong negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testLong(long, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code int} in the second argument
         * in the abstract method {@link #testLong(long, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfLong<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Int)}
             */
            boolean testLong(long x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Integer y) {
                return testLong(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndInt negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testLong(long, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code float} in the second argument
         * in the abstract method {@link #testLong(long, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfLong<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Float)}
             */
            boolean testLong(long x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Float y) {
                return testLong(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndFloat negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testLong(long, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code char} in the second argument
         * in the abstract method {@link #testLong(long, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfLong<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Char)}
             */
            boolean testLong(long x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Character y) {
                return testLong(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndChar negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testLong(long, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code short} in the second argument
         * in the abstract method {@link #testLong(long, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfLong<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Short)}
             */
            boolean testLong(long x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Short y) {
                return testLong(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndShort negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testLong(long, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testLong(long, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfLong<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Byte)}
             */
            boolean testLong(long x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Byte y) {
                return testLong(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndByte negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testLong(long, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfLong} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testLong(long, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfLong<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testLong(long, java.lang.Boolean)}
             */
            boolean testLong(long x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testLong(long x, java.lang.Boolean y) {
                return testLong(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfLong.AndBoolean negate() {
                return (x, y) -> !testLong(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfLong.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testLong(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testLong(long, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code long}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfLong.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testLong(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first of
     * {@link #applyInt(int, Object) applyInt} parameter to
     * be of type {@code int} and the second parameter to be of type {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfInt<AND> extends PrimitiveBiPredicate<java.lang.Integer, AND> {
        /**
         * Evaluates this predicate by receiving a {@code int} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code int} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testInt(int x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls {@link #testInt(int, Object)}
         */
        @Override
        default boolean test(java.lang.Integer x, AND y) {
            return testInt(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testInt(int, Object)} is the method that
         *           is negated
         *           and {@code OfInt} is returned.
         */
        @Override
        default OfInt<AND> negate() {
            return (x, y) -> !testInt(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code double}
         * @see BiPredicate#or
         */
        default OfInt<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testInt(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code long}
         * @see BiPredicate#or
         */
        default OfInt<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testInt(x, y) || other.testLong(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code int}
         * @see BiPredicate#or
         */
        default OfInt<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testInt(x, y) || other.testInt(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code float}
         * @see BiPredicate#or
         */
        default OfInt<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testInt(x, y) || other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code char}
         * @see BiPredicate#or
         */
        default OfInt<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code short}
         * @see BiPredicate#or
         */
        default OfInt<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code byte}
         * @see BiPredicate#or
         */
        default OfInt<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code boolean}
         * @see BiPredicate#or
         */
        default OfInt<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code double}
         * @see BiPredicate#and
         */
        default OfInt<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testInt(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code long}
         * @see BiPredicate#and
         */
        default OfInt<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testInt(x, y) && other.testLong(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code int}
         * @see BiPredicate#and
         */
        default OfInt<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testInt(x, y) && other.testInt(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code float}
         * @see BiPredicate#and
         */
        default OfInt<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testInt(x, y) && other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code char}
         * @see BiPredicate#and
         */
        default OfInt<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code short}
         * @see BiPredicate#and
         */
        default OfInt<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code byte}
         * @see BiPredicate#and
         */
        default OfInt<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testInt(int, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code int} to
         *           {@code boolean}
         * @see BiPredicate#and
         */
        default OfInt<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfInt} that expects a {@code double} in the second argument
         * in the abstract method {@link #testInt(int, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfInt<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Double)}
             */
            boolean testInt(int x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Double y) {
                return testInt(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndDouble negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testInt](int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code long} in the second argument
         * in the abstract method {@link #testInt(int, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfInt<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Long)}
             */
            boolean testInt(int x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Long y) {
                return testInt(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndLong negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testInt](int, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code int} in the second argument
         * in the abstract method {@link #testInt(int, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfInt<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Int)}
             */
            boolean testInt(int x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Integer y) {
                return testInt(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndInt negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testInt](int, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code float} in the second argument
         * in the abstract method {@link #testInt(int, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfInt<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Float)}
             */
            boolean testInt(int x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Float y) {
                return testInt(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndFloat negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testInt](int, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code char} in the second argument
         * in the abstract method {@link #testInt(int, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfInt<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Char)}
             */
            boolean testInt(int x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Character y) {
                return testInt(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndChar negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testInt](int, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code short} in the second argument
         * in the abstract method {@link #testInt(int, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfInt<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Short)}
             */
            boolean testInt(int x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Short y) {
                return testInt(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndShort negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testInt](int, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testInt(int, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfInt<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Byte)}
             */
            boolean testInt(int x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Byte y) {
                return testInt(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndByte negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testInt](int, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfInt} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testInt(int, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfInt<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testInt(int, java.lang.Boolean)}
             */
            boolean testInt(int x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testInt(int x, java.lang.Boolean y) {
                return testInt(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfInt.AndBoolean negate() {
                return (x, y) -> !testInt(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#or
             */
            default OfInt.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testInt(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code double}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code long}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code int}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code float}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code char}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code short}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code byte}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testInt](int, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code int} to
             *           {@code boolean}
             * @see BiPredicate#and
             */
            default OfInt.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testInt(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyFloat(float, Object) applyFloat} to
     * be of type {@code float} and the second parameter to be of type
     * {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfFloat<AND> extends PrimitiveBiPredicate<java.lang.Float, AND> {
        /**
         * Evaluates this predicate by receiving a {@code float} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code float} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testFloat(float x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls {@link #testFloat(float, Object)}
         */
        @Override
        default boolean test(java.lang.Float x, AND y) {
            return testFloat(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testFloat(float, Object)} is the method
         *           that is negated
         *           and {@code OfFloat} is returned.
         */
        @Override
        default OfFloat<AND> negate() {
            return (x, y) -> !testFloat(x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code double}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code long}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code int}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code float}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code char}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code short}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code byte}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code boolean}
         * @see BiPredicate#or
         */
        default OfFloat<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code double}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code int}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code float}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code char}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code short}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code byte}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testFloat(float, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code float}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default OfFloat<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfFloat} that expects a {@code double} in the second argument
         * in the abstract method {@link #testFloat(float, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfFloat<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Double)}
             */
            boolean testFloat(float x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Double y) {
                return testFloat(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndDouble negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code long} in the second argument
         * in the abstract method {@link #testFloat(float, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfFloat<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Long)}
             */
            boolean testFloat(float x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Long y) {
                return testFloat(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndLong negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code int} in the second argument
         * in the abstract method {@link #testFloat(float, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfFloat<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Int)}
             */
            boolean testFloat(float x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Integer y) {
                return testFloat(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndInt negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code float} in the second argument
         * in the abstract method {@link #testFloat(float, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfFloat<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Float)}
             */
            boolean testFloat(float x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Float y) {
                return testFloat(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndFloat negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testFloat(float, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code char} in the second argument
         * in the abstract method {@link #testFloat(float, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfFloat<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Char)}
             */
            boolean testFloat(float x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Character y) {
                return testFloat(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndChar negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code short} in the second argument
         * in the abstract method {@link #testFloat(float, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfFloat<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Short)}
             */
            boolean testFloat(float x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Short y) {
                return testFloat(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndShort negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testFloat(float, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testFloat(float, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfFloat<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Byte)}
             */
            boolean testFloat(float x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Byte y) {
                return testFloat(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndByte negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testFloat(float, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfFloat} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testFloat(float, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfFloat<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testFloat(float, java.lang.Boolean)}
             */
            boolean testFloat(float x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testFloat(float x, java.lang.Boolean y) {
                return testFloat(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfFloat.AndBoolean negate() {
                return (x, y) -> !testFloat(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfFloat.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testFloat(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testFloat(float, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code float}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfFloat.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testFloat(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyChar(char, Object) applyChar} to
     * be of type {@code char} and the second parameter to be of type {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfChar<AND> extends PrimitiveBiPredicate<java.lang.Character, AND> {
        /**
         * Evaluates this predicate by receiving a {@code char} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code char} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testChar(char x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls {@link #testChar(char, Object)}
         */
        @Override
        default boolean test(java.lang.Character x, AND y) {
            return testChar(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testChar(char, Object)} is the method
         *           that is negated
         *           and {@code OfChar} is returned.
         */
        @Override
        default OfChar<AND> negate() {
            return (x, y) -> !testChar(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code double}
         * @see BiPredicate#or
         */
        default OfChar<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testChar(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code long}
         * @see BiPredicate#or
         */
        default OfChar<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testChar(x, y) || other.testLong(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code int}
         * @see BiPredicate#or
         */
        default OfChar<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testChar(x, y) || other.testInt(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code float}
         * @see BiPredicate#or
         */
        default OfChar<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testChar(x, y) || other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code char}
         * @see BiPredicate#or
         */
        default OfChar<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testChar(x, y) || other.testChar(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code short}
         * @see BiPredicate#or
         */
        default OfChar<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code byte}
         * @see BiPredicate#or
         */
        default OfChar<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code boolean}
         * @see BiPredicate#or
         */
        default OfChar<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code double}
         * @see BiPredicate#and
         */
        default OfChar<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testChar(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default OfChar<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testChar(x, y) && other.testLong(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code int}
         * @see BiPredicate#and
         */
        default OfChar<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testChar(x, y) && other.testInt(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code float}
         * @see BiPredicate#and
         */
        default OfChar<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testChar(x, y) && other.testFloat(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code char}
         * @see BiPredicate#and
         */
        default OfChar<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testChar(x, y) && other.testChar(x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code short}
         * @see BiPredicate#and
         */
        default OfChar<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code byte}
         * @see BiPredicate#and
         */
        default OfChar<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
        }

        /**
         * Composes a {@code OfChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testChar(char, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code char}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default OfChar<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfChar} that expects a {@code double} in the second argument
         * in the abstract method {@link #testChar(char, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfChar<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Double)}
             */
            boolean testChar(char x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Double y) {
                return testChar(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndDouble negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code long} in the second argument
         * in the abstract method {@link #testChar(char, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfChar<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Long)}
             */
            boolean testChar(char x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Long y) {
                return testChar(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndLong negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testChar(char, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code int} in the second argument
         * in the abstract method {@link #testChar(char, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfChar<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Int)}
             */
            boolean testChar(char x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Integer y) {
                return testChar(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndInt negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testChar(char, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code float} in the second argument
         * in the abstract method {@link #testChar(char, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfChar<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Float)}
             */
            boolean testChar(char x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Float y) {
                return testChar(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndFloat negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testChar(char, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code char} in the second argument
         * in the abstract method {@link #testChar(char, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfChar<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Char)}
             */
            boolean testChar(char x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Character y) {
                return testChar(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndChar negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testChar(char, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code short} in the second argument
         * in the abstract method {@link #testChar(char, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfChar<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Short)}
             */
            boolean testChar(char x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Short y) {
                return testChar(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndShort negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testChar(char, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testChar(char, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfChar<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Byte)}
             */
            boolean testChar(char x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Byte y) {
                return testChar(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndByte negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testChar(char, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfChar} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testChar(char, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfChar<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testChar(char, java.lang.Boolean)}
             */
            boolean testChar(char x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testChar(char x, java.lang.Boolean y) {
                return testChar(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfChar.AndBoolean negate() {
                return (x, y) -> !testChar(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfChar.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testChar(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testChar(char, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testChar(char, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code char}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfChar.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testChar(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyShort(short, Object) applyShort} to
     * be of type {@code short} and the second parameter to be of type
     * {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfShort<AND> extends PrimitiveBiPredicate<java.lang.Short, AND> {
        /**
         * Evaluates this predicate by receiving a {@code short} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code short} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testShort(short x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls {@link #testShort(short, Object)}
         */
        @Override
        default boolean test(java.lang.Short x, AND y) {
            return testShort(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testShort(short, Object)} is the method
         *           that is negated
         *           and {@code OfShort} is returned.
         */
        @Override
        default OfShort<AND> negate() {
            return (x, y) -> !testShort(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code double}
         * @see BiPredicate#or
         */
        default OfShort<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testShort(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code long}
         * @see BiPredicate#or
         */
        default OfShort<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testShort(x, y) || other.testLong(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code int}
         * @see BiPredicate#or
         */
        default OfShort<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testShort(x, y) || other.testInt(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code float} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code float}
         * @see BiPredicate#or
         */
        default OfShort<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testShort(x, y) || other.testFloat(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code char}
         * @see BiPredicate#or
         */
        default OfShort<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code short} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code short}
         * @see BiPredicate#or
         */
        default OfShort<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testShort(x, y) || other.testShort(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code byte}
         * @see BiPredicate#or
         */
        default OfShort<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code boolean}
         * @see BiPredicate#or
         */
        default OfShort<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code double}
         * @see BiPredicate#and
         */
        default OfShort<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testShort(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default OfShort<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testShort(x, y) && other.testLong(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code int}
         * @see BiPredicate#and
         */
        default OfShort<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testShort(x, y) && other.testInt(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code float} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code float}
         * @see BiPredicate#and
         */
        default OfShort<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testShort(x, y) && other.testFloat(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code char}
         * @see BiPredicate#and
         */
        default OfShort<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code short} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code short}
         * @see BiPredicate#and
         */
        default OfShort<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testShort(x, y) && other.testShort(x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code byte}
         * @see BiPredicate#and
         */
        default OfShort<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
        }

        /**
         * Composes an {@code OfShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate t]hat accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testShort(short, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code short}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default OfShort<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfShort} that expects a {@code double} in the second argument
         * in the abstract method {@link #testShort(short, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfShort<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Double)}
             */
            boolean testShort(short x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Double y) {
                return testShort(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndDouble negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testShort(short, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code long} in the second argument
         * in the abstract method {@link #testShort(short, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfShort<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Long)}
             */
            boolean testShort(short x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Long y) {
                return testShort(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndLong negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testShort(short, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code int} in the second argument
         * in the abstract method {@link #testShort(short, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfShort<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Int)}
             */
            boolean testShort(short x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Integer y) {
                return testShort(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndInt negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testShort(short, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code float} in the second argument
         * in the abstract method {@link #testShort(short, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfShort<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Float)}
             */
            boolean testShort(short x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Float y) {
                return testShort(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndFloat negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testShort(short, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code char} in the second argument
         * in the abstract method {@link #testShort(short, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfShort<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Char)}
             */
            boolean testShort(short x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Character y) {
                return testShort(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndChar negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testShort(short, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code short} in the second argument
         * in the abstract method {@link #testShort(short, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfShort<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Short)}
             */
            boolean testShort(short x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Short y) {
                return testShort(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndShort negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testShort(short, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testShort(short, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfShort<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Byte)}
             */
            boolean testShort(short x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Byte y) {
                return testShort(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndByte negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testShort(short, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfShort} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testShort(short, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfShort<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testShort(short, java.lang.Boolean)}
             */
            boolean testShort(short x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testShort(short x, java.lang.Boolean y) {
                return testShort(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfShort.AndBoolean negate() {
                return (x, y) -> !testShort(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfShort.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testShort(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testShort(short, boolean)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code short}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfShort.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testShort(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyByte(byte, Object) applyByte} to
     * be of type {@code byte} and the second parameter to be of type {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfByte<AND> extends PrimitiveBiPredicate<java.lang.Byte, AND> {
        /**
         * Evaluates this predicate by receiving a {@code byte} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code byte} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testByte(byte x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls {@link #testByte(byte, Object)}
         */
        @Override
        default boolean test(java.lang.Byte x, AND y) {
            return testByte(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testByte(byte, Object)} is the method
         *           that is negated
         *           and {@code OfByte} is returned.
         */
        @Override
        default OfByte<AND> negate() {
            return (x, y) -> !testByte(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code double}
         * @see BiPredicate#or
         */
        default OfByte<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testByte(x, y) || other.testDouble(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code long}
         * @see BiPredicate#or
         */
        default OfByte<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testByte(x, y) || other.testLong(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code int}
         * @see BiPredicate#or
         */
        default OfByte<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testByte(x, y) || other.testInt(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code float}
         * @see BiPredicate#or
         */
        default OfByte<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testByte(x, y) || other.testFloat(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code char}
         * @see BiPredicate#or
         */
        default OfByte<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code short}
         * @see BiPredicate#or
         */
        default OfByte<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testByte(x, y) || other.testShort(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code byte}
         * @see BiPredicate#or
         */
        default OfByte<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testByte(x, y) || other.testByte(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code boolean}
         * @see BiPredicate#or
         */
        default OfByte<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code double}
         * @see BiPredicate#and
         */
        default OfByte<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testByte(x, y) && other.testDouble(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default OfByte<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testByte(x, y) && other.testLong(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code int}
         * @see BiPredicate#and
         */
        default OfByte<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testByte(x, y) && other.testInt(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code float}
         * @see BiPredicate#and
         */
        default OfByte<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testByte(x, y) && other.testFloat(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code char}
         * @see BiPredicate#and
         */
        default OfByte<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code short}
         * @see BiPredicate#and
         */
        default OfByte<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testByte(x, y) && other.testShort(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default OfByte<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testByte(x, y) && other.testByte(x, y);
        }

        /**
         * Composes an {@code OfByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose {@link #testByte(byte, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code byte}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default OfByte<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
        }

        /**
         * A {@code OfByte} that expects a {@code double} in the second argument
         * in the abstract method {@link #testByte(byte, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfByte<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Double)}
             */
            boolean testByte(byte x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Double y) {
                return testByte(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndDouble negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code long} in the second argument
         * in the abstract method {@link #testByte(byte, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfByte<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Long)}
             */
            boolean testByte(byte x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Long y) {
                return testByte(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndLong negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, longle)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndLong} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code long}
             * @return a newly composed predicate whose {@link #testByte(byte, long)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code int} in the second argument
         * in the abstract method {@link #testByte(byte, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfByte<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Int)}
             */
            boolean testByte(byte x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Integer y) {
                return testByte(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndInt negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, intble)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndInt} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code int}
             * @return a newly composed predicate whose {@link #testByte(byte, int)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code float} in the second argument
         * in the abstract method {@link #testByte(byte, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfByte<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Float)}
             */
            boolean testByte(byte x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Float y) {
                return testByte(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndFloat negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, floate)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndFloat} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code float}
             * @return a newly composed predicate whose {@link #testByte(byte, float)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code char} in the second argument
         * in the abstract method {@link #testByte(byte, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfByte<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Char)}
             */
            boolean testByte(byte x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Character y) {
                return testByte(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndChar negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, charle)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndChar} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code char}
             * @return a newly composed predicate whose {@link #testByte(byte, char)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code short} in the second argument
         * in the abstract method {@link #testByte(byte, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfByte<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Short)}
             */
            boolean testByte(byte x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Short y) {
                return testByte(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndShort negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, shorte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndShort} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code short}
             * @return a newly composed predicate whose {@link #testByte(byte, short)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testByte(byte, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfByte<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Byte)}
             */
            boolean testByte(byte x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Byte y) {
                return testByte(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndByte negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, bytele)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndByte} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code byte}
             * @return a newly composed predicate whose {@link #testByte(byte, byte)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }

        /**
         * A {@code OfByte} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testByte(byte, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfByte<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testByte(byte, java.lang.Boolean)}
             */
            boolean testByte(byte x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testByte(byte x, java.lang.Boolean y) {
                return testByte(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfByte.AndBoolean negate() {
                return (x, y) -> !testByte(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte}
             *              and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testByte(byte, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte,
             *         doubleboolean} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfByte.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testByte(x, y) || other.testBoolean(x != 0, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testDouble(x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testLong((long) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testInt((int) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testFloat((float) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testChar((char) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testShort((short) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testByte((byte) x, y);
            }

            /**
             * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code boolean}
             * @return a newly composed predicate whose {@link #testByte(byte, boolean)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code byte}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfByte.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testByte(x, y) && other.testBoolean(x != 0, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} that declares it's first parameter of
     * {@link #applyBoolean(boolean, Object) applyBoolean} to
     * be of type {@code boolean} and the second parameter to be of type
     * {@code <AND>}.
     * <p>
     * It overrides all methods from parent interfaces so as to make sure this
     * specialisation is maintained
     * during method chaining.
     */
    @FunctionalInterface
    interface OfBoolean<AND> extends PrimitiveBiPredicate<java.lang.Boolean, AND> {
        /**
         * Evaluates this predicate by receiving a {@code boolean} and an object
         * of type {@code <AND>}.
         * 
         * @param x the {@code boolean} input
         * @param y the input of type {@code <AND>}
         * @return {@code true} if the input arguments match the predicate, otherwise
         *         returns {@code false}
         */
        boolean testBoolean(boolean x, AND y);

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote The default implementation calls
         *           {@link #testBoolean(boolean, Object)}
         */
        @Override
        default boolean test(java.lang.Boolean x, AND y) {
            return testBoolean(x, y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote This ensures that {@link #testBoolean(boolean, Object)} is the
         *           method that is negated
         *           and {@code OfBoolean} is returned.
         */
        @Override
        default OfBoolean<AND> negate() {
            return (x, y) -> !testBoolean(x, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code double}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orDouble(OfDouble<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code long}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orLong(OfLong<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testLong(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code int}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orInt(OfInt<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testInt(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code float}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orFloat(OfFloat<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testFloat(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code char}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orChar(OfChar<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code short}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orShort(OfShort<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code byte}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orByte(OfByte<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <OR>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code boolean}
         * @see BiPredicate#or
         */
        default OfBoolean<AND> orBoolean(OfBoolean<AND> other) {
            return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code double} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code double}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andDouble(OfDouble<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code long} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code long}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andLong(OfLong<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testLong(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code int} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code int}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andInt(OfInt<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testInt(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code float} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code float}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andFloat(OfFloat<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testFloat(x ? 1 : 0, y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code char} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code char}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andChar(OfChar<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code short} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code short}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andShort(OfShort<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code byte} and it's first argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code byte}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andByte(OfByte<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
        }

        /**
         * Composes a {@code OfBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a {@code boolean} and it's first
         *              argument
         *              and an object of type {@code <AND>} as it's second argument
         * @return a newly composed predicate whose
         *         {@link #testBoolean(boolean, Object)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from
         *           {@code boolean} to {@code boolean}
         * @see BiPredicate#and
         */
        default OfBoolean<AND> andBoolean(OfBoolean<AND> other) {
            return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
        }

        /**
         * A {@code OfBoolean} that expects a {@code double} in the second argument
         * in the abstract method {@link #testBoolean(boolean, double)}.
         */
        @FunctionalInterface
        interface AndDouble extends OfBoolean<java.lang.Double> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Double)}
             */
            boolean testBoolean(boolean x, double y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Double y) {
                return testBoolean(x, (double) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndDouble negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orDouble(OfDouble.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orLong(OfLong.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orInt(OfInt.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orFloat(OfFloat.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orChar(OfChar.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orShort(OfShort.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orByte(OfByte.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndDouble orBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andDouble(OfDouble.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andLong(OfLong.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andInt(OfInt.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andFloat(OfFloat.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andChar(OfChar.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andShort(OfShort.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andByte(OfByte.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndDouble andBoolean(OfBoolean.AndDouble other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code long} in the second argument
         * in the abstract method {@link #testBoolean(boolean, long)}.
         */
        @FunctionalInterface
        interface AndLong extends OfBoolean<java.lang.Long> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Long)}
             */
            boolean testBoolean(boolean x, long y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Long y) {
                return testBoolean(x, (long) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndLong negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orDouble(OfDouble.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orLong(OfLong.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orInt(OfInt.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orFloat(OfFloat.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orChar(OfChar.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orShort(OfShort.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orByte(OfByte.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndLong orBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andDouble(OfDouble.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andLong(OfLong.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andInt(OfInt.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andFloat(OfFloat.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andChar(OfChar.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andShort(OfShort.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andByte(OfByte.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndLong andBoolean(OfBoolean.AndLong other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code int} in the second argument
         * in the abstract method {@link #testBoolean(boolean, int)}.
         */
        @FunctionalInterface
        interface AndInt extends OfBoolean<java.lang.Integer> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Int)}
             */
            boolean testBoolean(boolean x, int y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Integer y) {
                return testBoolean(x, (int) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndInt negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orDouble(OfDouble.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orLong(OfLong.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orInt(OfInt.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orFloat(OfFloat.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orChar(OfChar.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orShort(OfShort.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orByte(OfByte.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndInt orBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andDouble(OfDouble.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andLong(OfLong.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andInt(OfInt.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andFloat(OfFloat.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andChar(OfChar.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andShort(OfShort.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andByte(OfByte.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndInt andBoolean(OfBoolean.AndInt other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code float} in the second argument
         * in the abstract method {@link #testBoolean(boolean, float)}.
         */
        @FunctionalInterface
        interface AndFloat extends OfBoolean<java.lang.Float> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Float)}
             */
            boolean testBoolean(boolean x, float y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Float y) {
                return testBoolean(x, (float) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndFloat negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orDouble(OfDouble.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orLong(OfLong.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orInt(OfInt.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orFloat(OfFloat.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orChar(OfChar.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orShort(OfShort.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orByte(OfByte.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndFloat orBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andDouble(OfDouble.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andLong(OfLong.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andInt(OfInt.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andFloat(OfFloat.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andChar(OfChar.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andShort(OfShort.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andByte(OfByte.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndFloat andBoolean(OfBoolean.AndFloat other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code char} in the second argument
         * in the abstract method {@link #testBoolean(boolean, char)}.
         */
        @FunctionalInterface
        interface AndChar extends OfBoolean<java.lang.Character> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Char)}
             */
            boolean testBoolean(boolean x, char y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Character y) {
                return testBoolean(x, (char) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndChar negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orDouble(OfDouble.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orLong(OfLong.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orInt(OfInt.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orFloat(OfFloat.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orChar(OfChar.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orShort(OfShort.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orByte(OfByte.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndChar orBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andDouble(OfDouble.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andLong(OfLong.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andInt(OfInt.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andFloat(OfFloat.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andChar(OfChar.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andShort(OfShort.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andByte(OfByte.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndChar andBoolean(OfBoolean.AndChar other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code short} in the second argument
         * in the abstract method {@link #testBoolean(boolean, short)}.
         */
        @FunctionalInterface
        interface AndShort extends OfBoolean<java.lang.Short> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Short)}
             */
            boolean testBoolean(boolean x, short y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Short y) {
                return testBoolean(x, (short) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndShort negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orDouble(OfDouble.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orLong(OfLong.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orInt(OfInt.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orFloat(OfFloat.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orChar(OfChar.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orShort(OfShort.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orByte(OfByte.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndShort orBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andDouble(OfDouble.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andLong(OfLong.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andInt(OfInt.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andFloat(OfFloat.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andChar(OfChar.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andShort(OfShort.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andByte(OfByte.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndShort andBoolean(OfBoolean.AndShort other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code byte} in the second argument
         * in the abstract method {@link #testBoolean(boolean, byte)}.
         */
        @FunctionalInterface
        interface AndByte extends OfBoolean<java.lang.Byte> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Byte)}
             */
            boolean testBoolean(boolean x, byte y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Byte y) {
                return testBoolean(x, (byte) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndByte negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orDouble(OfDouble.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orLong(OfLong.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orInt(OfInt.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orFloat(OfFloat.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orChar(OfChar.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orShort(OfShort.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orByte(OfByte.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndByte orBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andDouble(OfDouble.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andLong(OfLong.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andInt(OfInt.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andFloat(OfFloat.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andChar(OfChar.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andShort(OfShort.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andByte(OfByte.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndByte andBoolean(OfBoolean.AndByte other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }

        /**
         * A {@code OfBoolean} that expects a {@code boolean} in the second argument
         * in the abstract method {@link #testBoolean(boolean, boolean)}.
         */
        @FunctionalInterface
        interface AndBoolean extends OfBoolean<java.lang.Boolean> {
            /**
             * Evaluates the predicate on the given arguments
             * 
             * @param x the first input argument
             * @param y the second input argument
             * @return {@code true} if the inputs matches the predicate, else returns
             *         {@code false}.
             * @apiNote This is the most specialised version of {@link #test} and should be
             *          preferred
             *          over {@link #testBoolean(boolean, java.lang.Boolean)}
             */
            boolean testBoolean(boolean x, boolean y);

            /**
             * {@inheritDoc}
             * 
             * @param x {@inheritDoc}
             * @param y {@inheritDoc}
             * @return {@inheritDoc}
             * @implNote The default implementation boxes the type of the second argument.
             */
            @Override
            default boolean testBoolean(boolean x, java.lang.Boolean y) {
                return testBoolean(x, (boolean) y);
            }

            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to use the specialised method
             */
            @Override
            default OfBoolean.AndBoolean negate() {
                return (x, y) -> !testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean}
             *              and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from
             *           {@code boolean} to {@code double}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orLong(OfLong.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts an {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orInt(OfInt.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orChar(OfChar.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orShort(OfShort.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orByte(OfByte.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code OR} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code OR} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#or}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#or
             */
            default OfBoolean.AndBoolean orBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) || other.testBoolean(x, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code double} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(double, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code double}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andDouble(OfDouble.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testDouble(x ? 1 : 0, y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code long} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(long, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code long}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andLong(OfLong.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testLong((long) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code int} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(int, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code int}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andInt(OfInt.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testInt((int) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code float} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(float, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code float}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andFloat(OfFloat.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testFloat((float) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code char} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(char, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code char}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andChar(OfChar.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testChar((char) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code short} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(short, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code short}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andShort(OfShort.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testShort((short) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code byte} and a {@code double}
             * @return a newly composed predicate whose {@link #testBoolean(byte, double)}
             *         is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code byte}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andByte(OfByte.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testByte((byte) (x ? 1 : 0), y);
            }

            /**
             * Composes a {@code AndDouble} that performs the logical {@code AND} of this
             * predicate and the argument's.
             * 
             * @param other a predicate that accepts a {@code boolean} and a {@code double}
             * @return a newly composed predicate whose
             *         {@link #testBoolean(boolean, double)} is
             *         the logical {@code AND} of this and the argument's specialised
             *         predicate method.
             * @apiNote This is part of a suite of methods within this interface that
             *          provides
             *          a primitive alternative to {@link BiPredicate#and}
             * @implNote the default implementation uses casting context from {@code double}
             *           to {@code boolean}
             * @see BiPredicate#and
             */
            default OfBoolean.AndBoolean andBoolean(OfBoolean.AndBoolean other) {
                return (x, y) -> testBoolean(x, y) && other.testBoolean(x, y);
            }
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code double}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndDouble<OF> extends PrimitiveBiPredicate<OF, java.lang.Double> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code double}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code double} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, double y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Double y) {
            return test(x, (double) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndDouble<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) (int) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndDouble<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndDouble} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndDouble<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code long}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndLong<OF> extends PrimitiveBiPredicate<OF, java.lang.Long> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code long}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code long} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, long y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Long y) {
            return test(x, (long) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndLong<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndLong<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndLong} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code long}
         * @return a newly composed predicate whose {@link #test(Object, long)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndLong<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code int}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndInt<OF> extends PrimitiveBiPredicate<OF, java.lang.Integer> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code int}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code int} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, int y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Integer y) {
            return test(x, (int) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndInt<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndInt<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndInt} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code int}
         * @return a newly composed predicate whose {@link #test(Object, int)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndInt<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code float}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndFloat<OF> extends PrimitiveBiPredicate<OF, java.lang.Float> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code float}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code float} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, float y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Float y) {
            return test(x, (float) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndFloat<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndFloat<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndFloat} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code float}
         * @return a newly composed predicate whose {@link #test(Object, float)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndFloat<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code char}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndChar<OF> extends PrimitiveBiPredicate<OF, java.lang.Character> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code char}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code char} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, char y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Character y) {
            return test(x, (char) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndChar<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndChar<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndChar} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code char}
         * @return a newly composed predicate whose {@link #test(Object, char)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndChar<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code short}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndShort<OF> extends PrimitiveBiPredicate<OF, java.lang.Short> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code short}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code short} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, short y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Short y) {
            return test(x, (short) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndShort<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndShort<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndShort} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code short}
         * @return a newly composed predicate whose {@link #test(Object, short)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndShort<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code byte}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndByte<OF> extends PrimitiveBiPredicate<OF, java.lang.Byte> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the first input of type {@code <OF>}
         * @param y the second input which is of type {@code byte}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code byte} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, byte y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Byte y) {
            return test(x, (byte) y);
        }

        /**
         * {@inheritDoc}
         * 
         * @return {@inheritDoc}
         * @implNote Overridden to ensure {@link #test(Object, double)} is called
         *           instead
         */
        @Override
        default AndByte<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndByte<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y != 0);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) y);
        }

        /**
         * Composes a {@code AndByte} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code byte}
         * @return a newly composed predicate whose {@link #test(Object, byte)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndByte<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y != 0);
        }
    }

    /**
     * A {@code PrimitiveBiPredicate} whose {@link #test} method requires a value of
     * type {@code <OF>} and a {@code boolean}.
     * 
     * @param <OF> the type of first argument for {@link #test}]
     */
    @FunctionalInterface
    interface AndBoolean<OF> extends PrimitiveBiPredicate<OF, java.lang.Boolean> {
        /**
         * Tests if the given arguments matches the predicate represented by this object
         * 
         * @param x the value first of type {@code <OF>}
         * @param y the {@input which is of type {@code boolean}
         * @return {@code true} if the inputs matches predicate else returns
         *         {@code false}
         * @apiNote This is a {@code boolean} specialisation of
         *          {@link #test(Object, Double)}
         *          and is recommended as the primary predicate method
         */
        boolean test(OF x, boolean y);

        /**
         * {@inheritDoc}
         * 
         * @param x {@inheritDoc}
         * @param y {@inheritDoc}
         * @return {@inheritDoc}
         * @implNote This calls {@link #test(Object, double)} casting the wrapper to the
         *           primtive
         */
        @Override
        default boolean test(OF x, java.lang.Boolean y) {
            return test(x, (boolean) y);
            /**
             * {@inheritDoc}
             * 
             * @return {@inheritDoc}
             * @implNote Overridden to ensure {@link #test(Object, double)} is called
             *           instead
             */
        }

        @Override
        default AndBoolean<OF> negate() {
            return (x, y) -> !test(x, y);
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code double}
         * @return a newly composed predicate whose {@link #test(Object, double)} is
         *         the logical {@code OR} of this and the argument's speciali]sed
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (long) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts an value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (int) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (float) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (char) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (short) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, (byte) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code OR} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code OR} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#or}
         * @see BiPredicate#or
         */
        default PrimitiveBiPredicate.AndBoolean<OF> orBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) || other.test(x, y);
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andDouble(PrimitiveBiPredicate.AndDouble<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code long}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andLong(PrimitiveBiPredicate.AndLong<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (long) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andInt(PrimitiveBiPredicate.AndInt<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (int) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andFloat(PrimitiveBiPredicate.AndFloat<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (float) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andChar(PrimitiveBiPredicate.AndChar<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (char) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andShort(PrimitiveBiPredicate.AndShort<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (short) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andByte(PrimitiveBiPredicate.AndByte<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, (byte) (y ? 1 : 0));
        }

        /**
         * Composes a {@code AndBoolean} that performs the logical {@code AND} of this
         * predicate and the argument's.
         * 
         * @param other a predicate that accepts a value of type {@code <OF>} and a
         *              {@code boolean}
         * @return a newly composed predicate whose {@link #test(Object, boolean)} is
         *         the logical {@code AND} of this and the argument's specialised
         *         predicate method.
         * @apiNote This is part of a suite of methods within this interface that
         *          provides
         *          a primitive alternative to {@link BiPredicate#and}
         * @implNote the default implementation uses casting context from {@code long}
         *           to {@code boolean}
         * @see BiPredicate#and
         */
        default PrimitiveBiPredicate.AndBoolean<OF> andBoolean(PrimitiveBiPredicate.AndBoolean<OF> other) {
            return (x, y) -> test(x, y) && other.test(x, y);
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @return {@inheritDoc}
     * @implNote This is overridden to account for primitive
     *           specialisation in the implementation i.e calling
     *           the appropriate specialised {@code testXxx} for the
     *           implementation rather than the generic
     *           {@link #test(Object, Object)}.
     */
    @Override
    default PrimitiveBiPredicate<OF, AND> negate() {
        return (x, y) -> !test(x, y);
    }

    /**
     * {@inheritDoc}
     * 
     * @param other {@inheritDoc}
     * @return {@inheritDoc}
     * @implNote This is overridden to account for primitive
     *           specialisation in the implementation i.e calling
     *           the appropriate specialised {@code testXxx} for the
     *           implementation rather than the generic
     *           {@link #test(Object, Object)}.
     */
    @Override
    default PrimitiveBiPredicate<OF, AND> or(BiPredicate<? super OF, ? super AND> other) {
        return (x, y) -> test(x, y) || other.test(x, y);
    }

    /**
     * {@inheritDoc}
     * 
     * @param other {@inheritDoc}
     * @return {@inheritDoc}
     * @implNote This is overridden to account for primitive
     *           specialisation in the implementation i.e calling
     *           the appropriate specialised {@code testXxx} for the
     *           implementation rather than the generic
     *           {@link #test(Object, Object)}.
     */
    @Override
    default PrimitiveBiPredicate<OF, AND> and(BiPredicate<? super OF, ? super AND> other) {
        return (x, y) -> test(x, y) && other.test(x, y);
    }
}
